{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nexports.__esModule = true;\nexports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\nexports.pathToRegexp = pathToRegexp;\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst matcherOptions = {\n  sensitive: false,\n  delimiter: '/',\n  decode: decodeParam\n};\nexports.matcherOptions = matcherOptions;\nconst customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {\n  strict: true\n});\nexports.customRouteMatcherOptions = customRouteMatcherOptions;\nvar _default = (customRoute = false) => {\n  return path => {\n    const keys = [];\n    const matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);\n    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys, matcherOptions);\n    return (pathname, params) => {\n      const res = pathname == null ? false : matcher(pathname);\n      if (!res) {\n        return false;\n      }\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete res.params[key.name];\n          }\n        }\n      }\n      return _objectSpread(_objectSpread({}, params), res.params);\n    };\n  };\n};\nexports.default = _default;\nfunction decodeParam(param) {\n  try {\n    return decodeURIComponent(param);\n  } catch (_) {\n    const err = new Error('failed to decode param');\n    err.code = 'DECODE_FAILED';\n    throw err;\n  }\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/path-match.ts"],"names":["matcherOptions","sensitive","delimiter","decode","decodeParam","customRouteMatcherOptions","strict","customRoute","path","keys","matcherRegex","pathToRegexp","matcher","regexpToFunction","pathname","params","res","key","name","param","decodeURIComponent","_","err","Error","code"],"mappings":";;;;;;;;;AAAA,IAAA,YAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,mCAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIO,MAAMA,cAAc,GAAG;EAC5BC,SAAS,EAAE,KADiB;EAE5BC,SAAS,EAAE,GAFiB;EAG5BC,MAAM,EAAEC;AAHoB,CAAvB;;AAMA,MAAMC,yBAAyB,GAAA,aAAA,CAAA,aAAA,KACjCL,cADoC;EAEvCM,MAAM,EAAE;AAF+B,EAAlC;;eAKQ,CAACC,WAAW,GAAG,KAAf,KAAyB;EACtC,OAAQC,IAAD,IAAkB;IACvB,MAAMC,IAAwB,GAAG,EAAjC;IACA,MAAMC,YAAY,GAAGC,YAAY,CAACA,YAAbA,CACnBH,IADmBG,EAEnBF,IAFmBE,EAGnBJ,WAAW,GAAGF,yBAAH,GAA+BL,cAHvBW,CAArB;IAKA,MAAMC,OAAO,GAAGD,YAAY,CAACE,gBAAbF,CACdD,YADcC,EAEdF,IAFcE,EAGdX,cAHcW,CAAhB;IAMA,OAAO,CAACG,QAAD,EAAsCC,MAAtC,KAAuD;MAC5D,MAAMC,GAAG,GAAGF,QAAQ,IAAI,IAAZA,GAAmB,KAAnBA,GAA2BF,OAAO,CAACE,QAAD,CAA9C;MACA,IAAI,CAACE,GAAL,EAAU;QACR,OAAO,KAAP;MACD;MAED,IAAIT,WAAJ,EAAiB;QACf,KAAK,MAAMU,GAAX,IAAkBR,IAAlB,EAAwB;UACtB;UACA;UACA,IAAI,OAAOQ,GAAG,CAACC,IAAX,KAAoB,QAAxB,EAAkC;YAChC,OAAQF,GAAG,CAACD,MAAL,CAAoBE,GAAG,CAACC,IAAxB,CAAP;UACD;QACF;MACF;MAED,OAAA,aAAA,CAAA,aAAA,KAAYH,MAAL,GAAgBC,GAAG,CAACD,MAA3B;IACD,CAjBD;EAkBD,CA/BD;AAgCD,C;;AAED,SAASX,WAAT,CAAqBe,KAArB,EAAoC;EAClC,IAAI;IACF,OAAOC,kBAAkB,CAACD,KAAD,CAAzB;EACD,CAAC,QAAOE,CAAP,EAAU;IACV,MAAMC,GAA8B,GAAG,IAAIC,KAAJ,CAAU,wBAAV,CAAvC;IACAD,GAAG,CAACE,IAAJF,GAAW,eAAXA;IACA,MAAMA,GAAN;EACD;AACF","sourcesContent":["import * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\nexport { pathToRegexp }\n\nexport const matcherOptions = {\n  sensitive: false,\n  delimiter: '/',\n  decode: decodeParam,\n}\n\nexport const customRouteMatcherOptions = {\n  ...matcherOptions,\n  strict: true,\n}\n\nexport default (customRoute = false) => {\n  return (path: string) => {\n    const keys: pathToRegexp.Key[] = []\n    const matcherRegex = pathToRegexp.pathToRegexp(\n      path,\n      keys,\n      customRoute ? customRouteMatcherOptions : matcherOptions\n    )\n    const matcher = pathToRegexp.regexpToFunction(\n      matcherRegex,\n      keys,\n      matcherOptions\n    )\n\n    return (pathname: string | null | undefined, params?: any) => {\n      const res = pathname == null ? false : matcher(pathname)\n      if (!res) {\n        return false\n      }\n\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete (res.params as any)[key.name]\n          }\n        }\n      }\n\n      return { ...params, ...res.params }\n    }\n  }\n}\n\nfunction decodeParam(param: string) {\n  try {\n    return decodeURIComponent(param)\n  } catch (_) {\n    const err: Error & { code?: string } = new Error('failed to decode param')\n    err.code = 'DECODE_FAILED'\n    throw err\n  }\n}\n"]},"metadata":{},"sourceType":"script"}